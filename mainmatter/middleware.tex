\chapter{Middleware Development}\label{ch:middleware}

\begin{keywords}
	middleware, netcode, packet, payload, proxy
\end{keywords}

The \gls{middleware} is a \planguage{c++} static library (\file{.lib}), developed with \software{VSCode} and \software{Microsoft Visual Studio}.

\section{Features}\label{sc:middleware:features}

The list of requirements was proposed and expanded upon by \company{ioTech}, based on the commercial viability of the final product (of which this \gls{middleware} is only a portion). The overall goal is to provide a public set of \glspl{api}, such that integration of any \gls{ts} could be done without having access to \gls{me}'s source code. Any \nth{3}--party company interested in using a \gls{ts} of their choice, could this seamlessly integrate it with minimal coding efforts and limited support from \company{ioTech}.

The current iteration of the \gls{middleware} achieves all of the following \glspl{feature}.

\begin{itemize}
	\item \FONTbold{black box} --- The \gls{middleware} should, by all intents and purposes, be a black box to any \nth{3}--party; only those parts required to successfully integrate a \gls{ts} should be grey boxed.
	\item \FONTbold{trivial} --- Implementing any \gls{ts} should be a simple, trivial, and documented process. Allowing a \nth{3}--party to independently develop the integration greatly reduces the support \software{ioTech} is expected to provide.
	\item \FONTbold{agnosticism} --- The \gls{netcode} part of the \gls{middleware} should be entirely hidden behind high-level functions: everything from sockets to memory handling should be handled inside the black box.
	\item \FONTbold{standardization} --- Vehicular standards, unit of measures, coordinate systems, and more should not refer to \gls{me}'s specific implementation, but rather to an industry accepted standard.\footnote{See \fref{sc:software:middleware}.}
\end{itemize}

The following \glspl{feature} are not fully supported yet, although the code is in place to allow an efficient transition to full support.

\begin{itemize}
	\item \FONTbold{plug-and-play} --- Switching between different \gls{ts} should be allowed by means of \gls{me} configuration files or in-game settings.
\end{itemize}

\section{Structure}\label{sc:middleware:structure}

The project is made of one core class, two helper namespaces, three data classes, and one required integration class.

\subsubsection{Helper}

\begin{filelist}
	\item logger.cpp
\end{filelist}

Provides utility functions to log the \gls{middleware}'s state and debug data. Logging is done on the \code{stderr} stream.

\begin{filelist}
	\item maths.cpp
\end{filelist}

Provides some basic maths functionality, mainly focused on matrix transformations between and within 3D systems. Among basic conversion functions, it defines a \code{Vector_t} struct, and an \code{apply_matrix()} function: this is used to convert position (velocity, acceleration) vectors between coordinate systems. See \fref{ax:math:matrix} for the relevant maths basics.

\begin{codelist}{maths.cpp --- apply\_matrix()}{46}
Vector_t apply_matrix(const Vector_t* vector, const transformMatrix matrix) {
	Vector_t transformed;

	transformed.x = vector->x*matrix[0][0] + vector->y*matrix[0][1] + vector->z*matrix[0][2] + 1*matrix[0][3];
	transformed.y = vector->x*matrix[1][0] + vector->y*matrix[1][1] + vector->z*matrix[1][2] + 1*matrix[1][3];
	transformed.z = vector->x*matrix[2][0] + vector->y*matrix[2][1] + vector->z*matrix[2][2] + 1*matrix[2][3];

	return transformed;
}
\end{codelist}

The functions in this namespace are exposed as \glspl{api} to \nth{3}--parties through the \file{maths.hpp} header.

\subsubsection{Data}

The three data classes represent generic traffic objects, and must be used in the integration process.

\begin{filelist}
	\item LightEntity.cpp
	\item TrafficEntity.cpp
	\item VehicleEntity.cpp
\end{filelist}

The data obtained from the \gls{ts} must be serialized in the appropriate class (e.g.\ data on an \gls{ai} vehicle is serialized in a \code{VehicleEntity} instance); the serialized instances obtained from \gls{me} must be deserialized into the appropriate \gls{ts} format (e.g.\ a \code{LightEntity} is deserialized into traffic lights raw data). This serialization/deserialization is in fact the only code that a \nth{3}--party must produce for the integration.

\code{TrafficEntity} is the parent class, that contains values common to all other entities (like position and id); \code{LightEntity} and \code{VehicleEntity} both extend the base class, each adding the data relevant to their function (e.g.\ \code{VehicleEntity} adds velocity and acceleration vectors, among other values).

The headers are fully documented to ease the coding by \nth{3}--parties.

\subsubsection{Core}

The core class is a pure virtual class, which means it must be extended by a child class that implements its pure virtual methods. \code{UDPConnector} silently handles the netcode, and only leaves the conversion to/from the \gls{ts} and \gls{me} to be implemented. As such the two pure virtual methods are \code{handle_RX_payload()} and \code{prepare_TX_payload()}, that respectively must handle the \gls{payload} received from the \gls{ts}, and prepare the data to be sent to the \gls{ts}.

Summarily, the execution flow is as follows:

\begin{itemize}
	\item an instance of \code{UDPConnector} is created by the implementing child class, via the \code{UDPConnector()} constructor;
	\item receiving and transmitting connections are opened between the \gls{ts} and \gls{me}, via \code{open_RX_connection()} and \code{open_TX_connection()};
	\item a \gls{packet} is received from the \gls{ts}, via \code{receive_packet()}, and placed in \code{m_payloadRX}
	\item the \gls{payload} is converted/serialized by \code{handle_RX_payload()}, and the returned \code{std::vector} consumed by \gls{me} for rendering;
	\item player data provided by \gls{me} is converted/deserialized by \code{handle_TX_payload()}, and the resulting \gls{payload} is placed in \code{m_payloadTX};
	\item a \gls{packet} is sent to the \gls{ts} with the \gls{payload} in \code{m_payloadTX}, via \code{send_packet()}.
\end{itemize}

\begin{image}
	{middleware/flow}{0.8}
	{\gls{middleware} execution flow}
	{im:middleware:flow}
	{}
	{}
\end{image}

A destructor is also used to properly close the connections and free all the used memory. Note that there is no requirement for a 1:1 relation between \glspl{packet} sent and \glspl{packet} received: both may happen independently and at different rates.

These methods are called within \gls{me}, as part of the integration with the game engine (\fref{ch:integration}).

\subsubsection{Integration}

Integrating any \gls{ts} into the \gls{middleware} (and thus \gls{me}) simply requires implementing \code{handle_RX_payload()} and \code{prepare_TX_payload()}. The former should take the \gls{payload} from the \gls{ts}, generate a list of matching \code{TrafficEntity}, and return them; how this is achieved is irrelevant from the \gls{middleware}'s perspective. The latter should take a list of \code{TrafficEntity} (more specifically, a \code{VehicleEntity} representing the player), covert it into the appropriate byte format required by the \gls{ts}, and place it into \code{m_payloadTX}.

\section{Netcode}\label{sc:middleware:netcode}

\begin{definition}{netcode}
\end{definition}

\begin{definition}{packet}
\end{definition}

\begin{definition}{payload}
\end{definition}

The netcode is fully handled by the core \code{UDPConnector} class: more specifically, by the methods detailed in \fref{tb:middleware:netcode}.

\input{mainmatter/tables/middleware/netcode}

Note that all the following code snippets have comments, debugging, and cross-compiler options removed for functional clarity. See \fref{ax:code:netcode} for an example of unmodified code.

\subsection{OS Sockets}

Windows \gls{os} sockets are provided by the \file{<Ws2tcpip.h>} standard \planguage{c} header. Socket references are saved in \code{int} variables, that represent a file descriptor for that specific socket.

\subsubsection{Receival Connection}

An in (receiving) socket is represented by a \code{struct sockaddr_in}. The file descriptor is obtained with a \code{socket()} call, with the \code{IPPROTO_UDP} option specifying the \gls{udp} protocol; options are specified with \code{setsockopt()}. Properties of the socket (like \gls{ip} and port) are directly set to the \code{struct}'s appropriate fields. The socket is set as non-blocking (i.e.\ the execution continues if nothing is found on a \code{recv()} call) via \code{ioctlsocket()} and the \code{FIONBIO} option. Finally, the socket is opened (bound) with \code{bind()}, by passing the file descriptor and the socket \code{struct}.

\begin{codelist}{UDPConnector.cpp --- open\_RX\_connection()}{73}
bool UDPConnector::open_RX_connection(const char* ip, const uint16_t port) {
	if (m_socketRXfd > -1)
		return false;

	struct sockaddr_in sock;
	uint32_t address;

	int opt;
	int result;

	InetPton(AF_INET, ip, &address);

	m_socketRXfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	if (m_socketRXfd == -1)
		return false;

	opt = 1;
	result = setsockopt(m_socketRXfd, SOL_SOCKET, SO_REUSEADDR, (char*) &opt, sizeof(opt));

	if (result == -1)
		return false;

	memset(&sock, 0, sizeof(sock));
	sock.sin_family      = AF_INET;
	sock.sin_addr.s_addr = address;
	sock.sin_port        = htons(port);

	result = bind(m_socketRXfd, (struct sockaddr*) &sock, sizeof(struct sockaddr_in));

	if (result == -1)
		return false;

	opt = 1;
	ioctlsocket(m_socketRXfd, FIONBIO, (u_long*) &opt);

	return true;
}
\end{codelist}

\subsubsection{Delivery Connection}

Opening an out (delivery) socket is similar, with only minor changes in the options for the socket. The major difference is the usage of \code{connect()} instead of \code{bind()}. The former is used to connect to a remote \code{ip:port}, whilst the latter provides an endpoint for external connections.

\begin{codelist}{UDPConnector.cpp --- open\_TX\_connection()}{143}
bool UDPConnector::open_TX_connection(const char* ip, const uint16_t port) {
	if (m_socketTXfd > -1)
		return false;

	struct sockaddr_in sock;
	uint32_t address;

	int opt;
	int result;

	InetPton(AF_INET, ip, &address);

	m_socketTXfd = socket(AF_INET, SOCK_DGRAM, 0);

	if (m_socketTXfd == -1)
		return false;

	opt = 1;
	result = setsockopt(m_socketTXfd, SOL_SOCKET, SO_REUSEADDR, (char*) &opt, sizeof(opt));

	if (result == -1)
		return false;

	opt = 1;
	result = setsockopt(m_socketTXfd, SOL_SOCKET, SO_BROADCAST, (char*) &opt, sizeof(opt));

	if (result == -1)
		return false;

	memset(&sock, 0, sizeof(sock));
	sock.sin_family      = AF_INET;
	sock.sin_addr.s_addr = address;
	sock.sin_port        = htons(port);

	result = connect(m_socketTXfd, (struct sockaddr*) &sock, sizeof(struct sockaddr_in));

	if (result == -1)
		return false;

	return true;
}
\end{codelist}

\subsubsection{Receiving Packet}

The \code{recv()} function polls the socket to see if any \glspl{packet} were sent to it. If one is found the \gls{packet}'s \gls{payload} is saved in \code{m_payloadRX}.

\begin{codelist}{UDPConnector.cpp --- receive\_packet()}{215}
bool UDPConnector::receive_packet() {
	int payloadSize = recv(m_socketRXfd, m_payloadRX, UDPCONNECTOR_ME_PAYLOAD_BUFFER, 0);

	if (payloadSize > 0)
		return true;
	else
		return false;
}
\end{codelist}

\subsubsection{Sending Packet}

The \code{send()} function takes a \gls{payload} (and its size) and sends a \gls{packet} containing it towards the specified remote \code{ip:port}.

\begin{codelist}{UDPConnector.cpp --- send\_packet()}{234}
bool UDPConnector::send_packet() {
	int result = send(m_socketTXfd, m_payloadTX, m_payloadTXSize, 0);

	if (result > 0)
		return true;
	else
		return false;
}
\end{codelist}

\subsection{0mq Sockets}

\software{0mq} sockets are provided by the \file{<zmq.h>} library \planguage{c} header. Socket references are saved as \code{void} pointers, that represent the memory allocation of that specific socket. A context must be instantiated as well before creating the sockets, that contains some general configuration settings about the \software{0mq} middleware process.

The \code{UDPConnector()} constructor instantiates a new context, and specifies the receive and send socket references. The current implementation uses the \FONTsmallcaps{pub/sub} model: a receiving socket subscribes to a remote publishing socket; multiple receiving sockets may subscribe to a single publish socket at the same time. The project's structure would only require a single subscriber, but the 1:1 \software{0mq} \FONTsmallcaps{req/rep} forces the server and client sendrates to be the same (each request must be followed by a reply).

\begin{codelist}{UDPConnector.cpp --- UDPConnector()}{63}
UDPConnector::UDPConnector() {
	m_context  = zmq_ctx_new();
	m_socketRX = zmq_socket(m_context, ZMQ_SUB);
	m_socketTX = zmq_socket(m_context, ZMQ_PUB);

	m_payloadRX = (char*) malloc(UDPCONNECTOR_ME_PAYLOAD_BUFFER);
	m_payloadTX = (char*) malloc(UDPCONNECTOR_ME_PAYLOAD_BUFFER);
}
\end{codelist}

\subsubsection{Receival Connection}

Opening a receival connection in \software{0mq} requires only a \code{connect()} call, specifying the socket reference and the remote \code{ip:port} to connect to. \code{zmq_setsockopt()} allows setting some options:

\begin{itemize}
	\item \code{ZMQ_CONFLATE} forces \software{0mq} to only retain the latest \gls{packet} received, and not keep a queue of received but not handled old \glspl{packet};
	\item \code{ZMQ_SUBSCRIBE} specifies the list the socket subscribes to (in this case, only one unnamed list exists).
\end{itemize}

\begin{codelist}{UDPConnector.cpp --- open\_RX\_connection()}{80}
bool UDPConnector::open_RX_connection(const char* ip, const uint16_t port) {

	std::string addr = std::string(ZMQBRIDGE_REMOTE_PROTOCOL) + "://" + std::string(ip) + ":" + std::to_string(port);

	int conflate = 1;
	zmq_setsockopt(m_socketRX, ZMQ_CONFLATE, &conflate, sizeof(conflate));
	zmq_connect(m_socketRX, addr.c_str());
	zmq_setsockopt(m_socketRX, ZMQ_SUBSCRIBE, "", 0);

	return true;
}
\end{codelist}

\subsubsection{Delivery Connection}

A delivery connection is set up with the \code{bind()} call, that creates a socket to which remote \software{0mq} processes can connect to. The \code{ZMQ_CONFLATE} option is also passed to avoid a \gls{packet} queueing.

\begin{codelist}{UDPConnector.cpp --- open\_TX\_connection()}{95}
bool UDPConnector::open_TX_connection(const char* ip, const uint16_t port) {
	std::string addr = std::string(ZMQBRIDGE_REMOTE_PROTOCOL) + "://" + std::string(ip) + ":" + std::to_string(port);

	int conflate = 1;
	zmq_setsockopt(m_socketTX, ZMQ_CONFLATE, &conflate, sizeof(conflate));
	zmq_bind(m_socketTX, addr.c_str());

	return true;
}
\end{codelist}

\subsubsection{Receiving Packet}

Receiving a \gls{packet} on a socket requires a single \code{zmq_recv()} call, specifying the \code{ZMQ_NOBLOCK} option for a non-blocking receive (the execution does not halt until a \gls{packet} is received). The \gls{payload} is placed in \code{m_payloadRX}.

\begin{codelist}{UDPConnector.cpp --- receive\_packet()}{109}
bool UDPConnector::receive_packet() {
	zmq_recv(m_socketRX, m_payloadRX, UDPCONNECTOR_ME_PAYLOAD_BUFFER, ZMQ_NOBLOCK);

	if (std::string(m_payloadRX).size() > 0)
		return true;
	else
		return false;
}
\end{codelist}

\subsubsection{Sending Packet}

Sending a \gls{packet} requires firstly sending the list name for that \gls{packet} (in this case, an empty name), and then adding the \gls{payload}. Both are done with the \code{zmq_send()} function, with the first part specifying \code{ZMQ_SENDMORE} to notify the receiver that more bytes from the same \gls{packet} are to be expected. The \gls{payload} sent is the one found in \code{m_payloadTX}.

\begin{codelist}{UDPConnector.cpp --- send\_packet()}{130}
bool UDPConnector::send_packet() {
	zmq_send(m_socketTX, "", 0, ZMQ_SNDMORE);
	int sentBytes = zmq_send(m_socketTX, m_payloadTX, m_payloadTXSize, 0);

	if (sentBytes > 0)
		return true;
	else
		return false;
}
\end{codelist}

\section{VTD Implementation}\label{sc:middleware:implementation}

For testing purposes and as a proof-of-concept, the implementation of \gls{vtd} was coded during the development of the \gls{middleware}.

As per specs two functions were overridden:

\begin{itemize}
	\item \code{handle_RX_payload()} converts the data from the \gls{rdb} format into matching \code{TrafficEntity};
	\item \code{prepare_TX_payload()} converts the data from \code{TrafficEntity} to the the \gls{rdb} format.
\end{itemize}

\gls{vtd} developer \company{Vires Simulationstechnologie GmbH} provides a full set of \glspl{api} to create, parse, print, and generally handle data in the \gls{rdb} format. This greatly eases the implementation, since it hides all the details on packaging, byte sizes, and more. Among the many datatypes, the ones relevant to this implementation are \code{RDB_OBJECT_STATE_t} and \code{RDB_VEHICLE_SYSTEMS_t}, that respectively hold data about an object's overall state (dimensions, position, vectors, type, name, etc.), and vehicle systems (sensors, lights, etc.).

The higher level functions that convert data are, for \gls{rdb} to \gls{me}:

\begin{itemize}
	\item \code{convert_entry_to_entity()} --- converts a datatype (passed as a pointer) into an appropriate \code{TrafficEntity}, adding it to a \code{std::vector<TrafficEntity>};
\end{itemize}

\FLOATnoindent whereas, for \gls{me} to \gls{rdb}:

\begin{itemize}
	\item \code{convert_entity_to_objectstate()} --- converts a \code{TrafficEntity} into an appropriate \gls{rdb} \code{RDB_OBJECT_STATE_t}, returning a memory point to that object;
	\item \code{convert_entity_to_vehiclesystems()} --- converts a \code{TrafficEntity} into an appropriate \gls{rdb} \code{RDB_VEHICLE_SYSTEMS_t}, returning a memory point to that object.
\end{itemize}

Since a single \code{rdb} \gls{packet} contains data for all the entities in the simulation, the receiving handling function must discriminate between the different datatypes, keeping count on how many bytes remain before the end of the whole \gls{packet}. \code{simTime} and \code{frameNo} are used to synchronize the simulation between \gls{vtd} and \gls{me}.

\begin{codelist}{VTDConnector.cpp --- handle\_RX\_payload()}{65}
std::vector<TrafficEntity*> VTDConnector::handle_RX_payload() {
	std::vector<TrafficEntity*> entities;

	RDB_MSG_t* message = (RDB_MSG_t*) m_payloadRX;

	if (!message || !message->hdr.dataSize || message->hdr.magicNo != RDB_MAGIC_NO)
		return entities;

	RDB_MSG_ENTRY_HDR_t* entry = (RDB_MSG_ENTRY_HDR_t*) (((char*) message) + message->hdr.headerSize);

	m_time  = message->hdr.simTime;
	m_frame = message->hdr.frameNo;

	uint32_t remainingBytes = message->hdr.dataSize;
	while (remainingBytes) {
		int elementsAmount = entry->elementSize ? (entry->dataSize / entry->elementSize) : 0;

		char* dataStart = (char*) entry;
		dataStart += entry->headerSize;

		while (elementsAmount) {
			switch (entry->pkgId) {
				case RDB_PKG_ID_OBJECT_STATE:
					convert_entry_to_entity(&entities, (RDB_OBJECT_STATE_t*) dataStart, entry->flags & RDB_PKG_FLAG_EXTENDED);
					break;
				case RDB_PKG_ID_VEHICLE_SYSTEMS:
					convert_entry_to_entity(&entities, (RDB_VEHICLE_SYSTEMS_t*) dataStart);
					break;
				case RDB_PKG_ID_TRAFFIC_LIGHT:
					convert_entry_to_entity(&entities, (RDB_TRAFFIC_LIGHT_t*) dataStart);
					break;
				default:
					break;
			}
			dataStart += entry->elementSize;
			elementsAmount -= 1;
		}

		remainingBytes -= (entry->headerSize + entry->dataSize);
		if (remainingBytes)
			entry = (RDB_MSG_ENTRY_HDR_t*) (((char*) entry) + entry->headerSize + entry->dataSize);
	}

	return entities;
}
\end{codelist}

Internally, \code{convert_entry_to_entity()} calls another method that checks whether a \code{TrafficEntity} with the found \code{id} was already added to the \code{std::vector}: f so, it gets its reference, and adds the data to it; otherwise, it instantiates a new (appropriate) \code{TrafficEntity} and adds it to the \code{std::vector}.

\begin{codelist}{VTDConnector.cpp --- prepare\_TX\_payload()}{118}
TrafficEntity* VTDConnector::get_add_entity(std::vector<TrafficEntity*>* entities, const uint8_t id, const TrafficEntity::AVAILABLE_ENTITIES_e type) {
	for (std::vector<TrafficEntity*>::const_iterator iter = entities->begin(); iter != entities->end(); iter++)
		if ((*iter)->id == id)
			return (*iter);

	TrafficEntity* entity;
	switch (type) {
		case TrafficEntity::AVAILABLE_ENTITIES_e::ENTITY_VEHICLE:
			entity = new VehicleEntity();
			break;
		case TrafficEntity::AVAILABLE_ENTITIES_e::ENTITY_TRAFFICLIGHT:
			entity = new LightEntity();
			break;
		case TrafficEntity::AVAILABLE_ENTITIES_e::ENTITY_TRAFFIC:
		default:
			entity = new TrafficEntity();
			break;
	}

	entities->push_back(entity);

	return entity;
}
\end{codelist}

The actual conversion is handled vector by vector. A temporary \code{maths::vector vector} is used to apply the transformation matrices, that transform vectors from \gls{vtd}'s coordinate system to the \gls{middleware}'s. The center point is moved first with the \code{move_pivot_front()} call, depending on the vehicle's heading (\code{entry->base.pos.h}). The \gls{rdb} vector is then copied member-by-member to the temporary \code{vector}, and two transform matrices are applied: one to align the scenario, and one to transform the coordinate systems. Finally, the data is copied member-by-member from the temporary \code{vector} to the \code{TrafficEntity}'s \code{inertialPosition} property. A similar process is used for angles, velocity, and acceleration vectors.

\begin{codelist}{VTDConnector.cpp --- convert\_entry\_to\_entity()}{162}
void VTDConnector::convert_entry_to_entity(std::vector<TrafficEntity*>* entities, const RDB_OBJECT_STATE_t* entry, bool isExtended) {
	VehicleEntity* entity = (VehicleEntity*) get_add_entity(entities, entry->base.id - 1, TrafficEntity::AVAILABLE_ENTITIES_e::ENTITY_VEHICLE);

	entity->id = entry->base.id - 1;

	maths::Vector_t vector;

	if (entry->base.pos.type == RDB_COORD_TYPE_INERTIAL) {
		entity->inertialPosition.isValid = true;

		transformMatrices.alpha = entry->base.pos.h;
		transformMatrices.move_pivot_front();

		vector.x = entry->base.pos.x;
		vector.y = entry->base.pos.y;
		vector.z = entry->base.pos.z;

		vector = maths::apply_matrix(&(vector), transformMatrices.testTrack.VTDToME);
		vector = maths::apply_matrix(&(vector), transformMatrices.VTDToSAE);

		entity->inertialPosition.x = vector.x;
		entity->inertialPosition.y = vector.y;
		entity->inertialPosition.z = vector.z;
	}

	entity->orientation.pitch = maths::rad_to_deg(entry->base.pos.p);
	entity->orientation.roll  = maths::rad_to_deg(entry->base.pos.r);
	entity->orientation.yaw   = maths::rad_to_deg(entry->base.pos.h) + 90;

	if (isExtended) {
		vector.x = entry->ext.speed.x;
		vector.y = entry->ext.speed.y;
		vector.z = entry->ext.speed.z;

		vector = maths::apply_matrix(&(vector), transformMatrices.VTDToSAE);

		entity->velocities.x     = vector.x;
		entity->velocities.y     = vector.y;
		entity->velocities.z     = vector.z;
		entity->velocities.pitch = maths::rad_to_deg(entry->ext.speed.p);
		entity->velocities.roll  = maths::rad_to_deg(entry->ext.speed.r);
		entity->velocities.yaw   = maths::rad_to_deg(entry->ext.speed.h) + 90;

		vector.x = entry->ext.accel.x;
		vector.y = entry->ext.accel.y;
		vector.z = entry->ext.accel.z;

		vector = maths::apply_matrix(&(vector), transformMatrices.VTDToSAE);

		entity->accelerations.x     = vector.x;
		entity->accelerations.y     = vector.y;
		entity->accelerations.z     = vector.z;
		entity->accelerations.pitch = maths::rad_to_deg(entry->ext.accel.p);
		entity->accelerations.roll  = maths::rad_to_deg(entry->ext.accel.r);
		entity->accelerations.yaw   = maths::rad_to_deg(entry->ext.accel.h) + 90;
	}

	switch (entry->base.cfgModelId) {
		case 3:
			entity->type = VehicleEntity::TYPE_HATCHBACK;
			break;
		case 5:
		case 15:
			entity->type = VehicleEntity::TYPE_SEDAN;
			break;
	}
}
\end{codelist}

The opposite conversion (\gls{me} to \gls{vtd}) is similar.

\section{Testing}\label{sc:middleware:testing}

Testing was done continuously during the development process, by comparing the visual rendering in \gls{me} with the traffic behaviour in \gls{vtd}. \gls{me} runs on a Windows 10 machine, whilst \gls{vtd} runs on a guest \gls{vm}: the \gls{vm} is set to obtain its own \gls{ip} from the network's \gls{dhcp} server, to separate the host and guest on the network and fully generalize the testing.

\begin{image}
	{middleware/environment}{1.0}
	{testing environment}
	{im:middleware:environment}
	{}
	{}
\end{image} % FIXME check the ports on the MSI

\software{0mq} requires all the entities part of the network to implement their sockets. This becomes a problem when testing \gls{vtd} with \software{0mq}, since \gls{vtd} is closed source and does not use \software{0mq} sockets. To avoid this issue, a \gls{proxy} was coded, such that it receives/sends from \gls{vtd} on normal sockets, and forwards the \gls{payload} sending/receiving to the \gls{middleware} on \software{0mq} sockets.

\subsection{The Proxy}

\begin{definition}{proxy}
\end{definition}

This \gls{proxy} resides on the \gls{vm} hosting \gls{vtd}; additionally, the expected ports are modified on the \gls{middleware}'s side. This completely hides the bridge's presence to the \gls{middleware}, that has no knowledge that a \gls{proxy} is between it and \gls{vtd}.\footnote{The additional latency introduced by the \gls{proxy} is unsubstantial, see \fref{sc:performance:proxy}}.

\begin{image}
	{middleware/zmqenvironment}{1.0}
	{\software{0mq} testing environment}
	{im:middleware:zmqenvironment}
	{}
	{}
\end{image}

The \gls{proxy} opens two connection "lanes", one upstream (data flowing out the \gls{vm}) and one downstream (data flowing in the \gls{vm}). It does so by creating four sockets, each of the appropriate type: \gls{os} towards \gls{vtd}, \software{0mq} towards the \gls{middleware}. It then waits for \glspl{packet} to be received from either side, and reroutes them with no modifications. The full lower level code that handles the rerouting can be found in \fref{ax:code:proxy}.

\begin{codelist}{start.cpp --- main()}{12}
int main() {
	ZMQBridge::Bridge bridge;

	bridge.open_upstream_lane();
	bridge.open_downstream_lane();

	while (true) {
		bridge.flow_upstream();
		bridge.flow_downstream();
	}

	bridge.close_upstream_lane();
	bridge.close_downstream_lane();

	bridge.~Bridge();

	return 0;
}
\end{codelist}

Sockets are created and handled nearly identically as seen in \fref{sc:middleware:netcode}.

\section{Recap}\label{sc:middleware:recap}

The \gls{middleware}'s requirements and matching features were presented and explained in \fref{sc:middleware:features}; its overall structure was then described in \fref{sc:middleware:structure}, by discriminating between helper namespaces, data objects, the core class, and the necessary integration class. \fref{sc:middleware:netcode} summarily details the \gls{netcode} implementation, both with \gls{os} and \software{0mq} sockets. \fref{sc:middleware:implementation} broadly explains how \gls{vtd} was integrated as a proof-of-concept. Finally, \fref{sc:middleware:testing} presented the development and testing environment, explaining why a \gls{proxy} is needed to test \software{0mq}, where it resides, and how it works.
