\chapter{Software Descriptions}\label{ch:software}

\begin{keywords}
	me, middleware, vtd
\end{keywords}

This chapter describes the software involved in the development. \gls{me} is the game engine on top of which \software{Project Cars} is built; \gls{vtd} by \company{Vires Simulationstechnologie GmbH} contains the traffic software, that sends and accepts data about its entities in the proprietary \gls{rdb} format; the \gls{middleware} is a home-grown solution to connect the two previous software.

Additionally, the two socket libraries methods used to implement two distinct versions of the \gls{middleware} are also summarily presented. More information and details on their implementation can be found in \fref{ch:middleware}.

\section{Overall Structure}\label{ch_software:overall}

Before analysing in detail each software an overall view is presented, treating each as a black box with a specific function. The \gls{middleware} offers two functions (or a two-way function): it converts data from a proprietary format (like \gls{rdb}) to \gls{me}'s accepted format, and the opposite. Details on how it accomplishes this, how it abstracts to any possible proprietary format, and the intermediate third \gls{sae} format can be found in \fref{ch:middleware}.

\input{mainmatter/tables/software/functions}

The overall black box structure is summarized as in \fref{im:software:structure}. The difference in implementation between \gls{os} sockets and \software{0mq} sockets is only visible after grey boxing the \gls{middleware} and \gls{vtd}, so it is omitted here.

\begin{figure}[!ht]
	\FLOATcenter{}
	\FIGUREinclude[width=\FLOATtextwidth]{mainmatter/images/software/structure.pdf}

    \caption{overall structure}\label{im:software:structure}
\end{figure}

Data about the traffic entities flows from \gls{vtd} to the \gls{middleware} in the \gls{rdb} format; their respective \code{in} and \code{out} ports are network sockets, with the two host \glspl{os} being reachable via \gls{ip} with each other. The data is converted into an \gls{me} digestible format by the \gls{middleware}, and then supplied to \gls{me}: this is actually done in-memory (the implementation of the \gls{middleware} runs within \gls{me}), hence the ports are in this case abstractions for memory management. Similarly, data about the player vehicle flows in the opposite way: \gls{me} supplies the \gls{middleware} with the data, the \gls{middleware} converts it into the \gls{rdb} format, and sends it to \gls{vtd}.

This feedback loop is repeated continuously for the entire duration of the simulation. The right-to-left flow moves the "ego" car within the traffic simulation, allowing its entities to react in real time; the left-to-right flow allows \gls{me} to render the traffic entities on screen, displaying them to the end-user. Time and spatial synchronization issues are omitted in this simplified description, details can be found in \fref{sc:integration:approach}. % TODO: check correct ref

This structure is akin to a client-server paradigm: here the client is \gls{me}, and the server is \gls{vtd}\footnote{This distinction is purely arbitrary, since it is a 1:1 communication loop.}. \Glspl{sendrate} and \glspl{tickrate} are not synchronized: both software are running at their own simulation paces; \gls{vtd}'s sendrate is fully configurable; \gls{me}'s sendrate is equal to its framerate.

\section{Madness Engine}\label{sc:software:madnessengine}

The Madness Engine is a massive, monolithic, proprietary, closed-source game engine, focused on high-fidelity driving simulations, and written in \planguage{c++}. Most of the low level functions provided by standard libraries were also re-written to adapt to different platforms (Linux, Windows, Playstation, Xbox).

\begin{itemize}
	\item \FONTbold{massive}: the engine is an all-encompassing collection of submodules, that can be freely interchanged to build consumer-grade applications like \software{Project Cars}.
	\item \FONTbold{monolithic}: the engine handles the entire simulation stack on every abstractions level, like \gls{gui}, physics, \gls{ai}, rendering, threading, memory management, and more.
	\item \FONTbold{proprietary}: the engine was developed entirely by \gls{sms} in a fifteen year period, through subsequent modifications and additions.
	\item \FONTbold{closed source}: the code is not freely available, and is protected with \glspl{nda}.
\end{itemize}

The details on how the engine operates at mid to low level are covered by \gls{nda} and too technical to be covered here. The overall simulation stack can nevertheless be described, enough to grasp the main concepts and the reasonings in \fref{ch:integration}. Roughly, Each simulation tick (that may or may not be tied to framerate) steps through logic, \gls{ai}, physics, and rendering; the required data is passed from one step to the next, converted to a lower level of abstraction as it flows down.

\begin{figure}[!ht]
	\FLOATcenter{}
	\FIGUREinclude[width=0.3\FLOATtextwidth]{mainmatter/images/software/mestack.pdf}

    \caption{\gls{me} simulation stack}\label{im:software:mestack}
\end{figure}

A vague example could be that of an \gls{ai} car that wants to overtake a slower player, during a race. This would take an unknown amount of simulation tick, each flowing summarily as follows:

\begin{itemize}
	\item The race \FONTbold{logic} handles the high-level data about standings, laps remaining, times, ideal racing lines, and more; this data is passed to each \gls{ai} and the player, to aid in their decision making.
	\item The \FONTbold{\gls{ai}} receives this data and at some point decides to overtake the player: to do so, it leaves the ideal racing lines (by taking a risk) and manoeuvres to perform the overtake.
	\item The commands received from the \gls{ai} are handled by the \FONTbold{physics} system to provide a proper response and behaviour of the car in the current driving situations. This may account (especially in the case of the player) for things like weight transfer, downforce, steering force, bumps, puddles, wind, and much more.
	\item The \FONTbold{rendering} system takes the spatial coordinates supplied by the physics and uses them to properly render the scene.
\end{itemize}

Although the nature of the data passed in the logic-\gls{ai} and \gls{ai}-physics transitions can be fuzzily assumed, (a subset of) the data passed in the physics-rendering transition should be instead precisely defined. To locate an object in the environment the physics system outputs, among many other metrics, its spatial and rotational coordinates: these two metrics are enough for the rendering system to show a car moving in the scene.

\subsection{Coordinate System} % TODO: check

\begin{figure}[!ht]
	\FLOATcenter{}
	\FIGUREinclude[width=\FLOATtextwidth]{mainmatter/images/software/mecoords.pdf}

    \caption{\gls{me} coordinate system}\label{im:software:mecoords}
\end{figure}

\subsubsection{Absolute}

The absolute coordinate system is an Euclidean space on three axes, with the $(0,0)$ origin being an arbitrary "origin" point in the scenario. Measures are in meters (\si{\meter}).

\begin{itemize}
	\item \code{x}: North-South axis; positive North
	\item \code{y}: vertical axis; positive down
	\item \code{z}: West-East axis; positive East
\end{itemize}

\subsubsection{Relative}

The reference point and $(0,0)$ origin for the geometry of each vehicle is the mid point of the front wheels axle. Measures are also in meters (\si{\meter}).

\begin{itemize}
	\item \code{x}: vehicle length; positive forward
	\item \code{y}: vehicle height; positive down
	\item \code{z}: vehicle width; positive left
\end{itemize}

Rotations are internally handled by the engine as quaternions, although for simplicity Euclidean angles will be used instead. Measures are in radians (\si{\radian}).

\begin{itemize}
	\item \code{pitch}: insists on the \code{x}-\code{y} plane; unwraps from the positive \code{x} semi-axis; $-\pi \leqslant \alpha \leqslant 0$ in the negative (upper) semiplane, $0 \leqslant \alpha \leqslant \pi$ in the positive (lower) semiplane
	\item \code{yaw}: insists on the \code{x}-\code{z} plane; unwraps from the positive \code{x} semi-axis; $-\pi \leqslant \alpha \leqslant 0$ in the negative (right) semiplane, $0 \leqslant \alpha \leqslant \pi$ in the positive (left) semiplane
	\item \code{roll}: insists on the \code{y}-\code{z} plane; unwraps from the positive \code{z} semi-axis; $-\pi \leqslant \alpha \leqslant 0$ in the negative (upper) semiplane, $0 \leqslant \alpha \leqslant \pi$ in the positive (lower) semiplane\footnote{The roll angle visualization is left to the reader.}
\end{itemize}

\section{Virtual Test Drive}\label{sc:software:vtd}

\subsection{Runtime Data Bus}

\section{Middleware}\label{sc:software:middleware}

\subsection{\textsc{os} Sockets}

\subsection{0mq Sockets}

\section{Recap}\label{sc:software:recap}
