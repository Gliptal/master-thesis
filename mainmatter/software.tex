\chapter{Software Descriptions}\label{ch:software}

\begin{keywords}
	me, middleware, vtd
\end{keywords}

This chapter describes the software involved in the development. \gls{me} is the game engine on top of which \software{Project Cars} is built; \gls{vtd} by \company{Vires Simulationstechnologie GmbH} contains the traffic software, that sends and accepts data about its entities in the proprietary \gls{rdb} format; the \gls{middleware} is a home-grown solution to connect the two previous software.

Additionally, the two socket libraries methods used to implement two distinct versions of the \gls{middleware} are also summarily presented. More information and details on their implementation can be found in \fref{ch:middleware}.

\section{Overall Structure}\label{sc:software:overall}

Before analysing in detail each software an overall view is presented, treating each as a black box with a specific function. The \gls{middleware} offers two functions (or a two-way function): it converts data from a proprietary format (like \gls{rdb}) to \gls{me}'s accepted format, and the opposite. Details on how it accomplishes this, how it abstracts to any possible proprietary format, and the intermediate third \gls{sae} format can be found in \fref{ch:middleware}.

\input{mainmatter/tables/software/functions}

The overall black box structure is summarized as in \fref{im:software:structure}. The difference in implementation between \gls{os} sockets and \software{0mq} sockets is only visible after grey boxing the \gls{middleware} and \gls{vtd}, so it is omitted here.

\begin{image}
	{software/structure}{1.0}
	{overall structure}
	{im:software:structure}
	{}
\end{image}

Data about the traffic entities flows from \gls{vtd} to the \gls{middleware} in the \gls{rdb} format; their respective \code{in} and \code{out} ports are network sockets, with the two host \glspl{os} being reachable via \gls{ip} with each other. The data is converted into an \gls{me} digestible format by the \gls{middleware}, and then supplied to \gls{me}: this is actually done in-memory (the implementation of the \gls{middleware} runs within \gls{me}), hence the ports are in this case abstractions for memory management. Similarly, data about the player vehicle flows in the opposite way: \gls{me} supplies the \gls{middleware} with the data, the \gls{middleware} converts it into the \gls{rdb} format, and sends it to \gls{vtd}.

This feedback loop is repeated continuously for the entire duration of the simulation. The right-to-left flow moves the "ego" car within the traffic simulation, allowing its entities to react in real time; the left-to-right flow allows \gls{me} to render the traffic entities on screen, displaying them to the end-user. Time and spatial synchronization issues are omitted in this simplified description, details can be found in \fref{sc:integration:approach}. % FIXME check correct ref

This structure is akin to a client-server paradigm: here the client is \gls{me}, and the server is \gls{vtd}\footnote{This distinction is purely arbitrary, since it is a 1:1 communication loop.}. \Glspl{sendrate} and \glspl{tickrate} are not synchronized: both software are running at their own simulation paces; \gls{vtd}'s sendrate is fully configurable; \gls{me}'s sendrate is equal to its framerate.

\section{Madness Engine}\label{sc:software:madnessengine}

The Madness Engine is a massive, monolithic, proprietary, closed-source game engine, focused on high-fidelity driving simulations, and written in \planguage{c++}. Most of the low level functions provided by standard libraries were also re-written to adapt to different platforms (Linux, Windows, Playstation, Xbox).

\begin{itemize}
	\item \FONTbold{massive}: the engine is an all-encompassing collection of submodules, that can be freely interchanged to build consumer-grade applications like \software{Project Cars}.
	\item \FONTbold{monolithic}: the engine handles the entire simulation stack on every abstractions level, like \gls{gui}, physics, \gls{ai}, rendering, threading, memory management, and more.
	\item \FONTbold{proprietary}: the engine was developed entirely by \gls{sms} in a fifteen year period, through subsequent modifications and additions.
	\item \FONTbold{closed source}: the code is not freely available, and is protected with \glspl{nda}.
\end{itemize}

The details on how the engine operates at mid to low level are covered by \gls{nda} and too technical to be covered here. The overall simulation stack can nevertheless be described, enough to grasp the main concepts and the reasonings in \fref{ch:integration}. Roughly, Each simulation tick (that may or may not be tied to framerate) steps through logic, \gls{ai}, physics, and rendering; the required data is passed from one step to the next, converted to a lower level of abstraction as it flows down.

\begin{image}
	{software/mestack}{0.3}
	{\gls{me} simulation stack}
	{im:software:mestack}
	{}
\end{image}

A vague example could be that of an \gls{ai} car that wants to overtake a slower player, during a race. This would take an unknown amount of simulation tick, each flowing summarily as follows:

\begin{itemize}
	\item The race \FONTbold{logic} handles the high-level data about standings, laps remaining, times, ideal racing lines, and more; this data is passed to each \gls{ai} and the player, to aid in their decision making.
	\item The \FONTbold{\gls{ai}} receives this data and at some point decides to overtake the player: to do so, it leaves the ideal racing lines (by taking a risk) and manoeuvres to perform the overtake.
	\item The commands received from the \gls{ai} are handled by the \FONTbold{physics} system to provide a proper response and behaviour of the car in the current driving situations. This may account (especially in the case of the player) for things like weight transfer, downforce, steering force, bumps, puddles, wind, and much more.
	\item The \FONTbold{rendering} system takes the spatial coordinates supplied by the physics and uses them to properly render the scene.
\end{itemize}

Although the nature of the data passed in the logic-\gls{ai} and \gls{ai}-physics transitions can be fuzzily assumed, (a subset of) the data passed in the physics-rendering transition should be instead precisely defined. To locate an object in the environment the physics system outputs, among many other metrics, its spatial and rotational coordinates: these two metrics are enough for the rendering system to show a car moving in the scene.

\subsection{Coordinate System} % FIXME check correctness

\begin{image}
	{software/mecoords}{1.0}
	{\gls{me} coordinate system}
	{im:software:mecoords}
	{}
\end{image}

\subsubsection{Absolute}

The absolute coordinate system is an Euclidean space on three axes, with the $(0,0,0)$ origin being an arbitrary "origin" point in the scenario. Measures are in meters (\si{\meter}).

\begin{itemize}
	\item \code{x}: North-South axis; positive North
	\item \code{y}: vertical axis; positive down
	\item \code{z}: West-East axis; positive East
\end{itemize}

\subsubsection{Relative}

The reference point and $(0,0,0)$ origin for the geometry of each vehicle is the mid point of the front wheels axle. Measures are also in meters (\si{\meter}).

\begin{itemize}
	\item \code{x}: vehicle length; positive forward
	\item \code{y}: vehicle height; positive down
	\item \code{z}: vehicle width; positive left
\end{itemize}

Rotations are internally handled by the engine as quaternions, although for simplicity Euclidean angles will be used instead. Measures are in radians (\si{\radian}).\footnote{The roll angle visualization is left to the reader.}

\begin{itemize}
	\item \code{pitch}: insists on the \code{x}-\code{y} plane; unwraps from the positive \code{x} semi-axis; $-\pi \leqslant \alpha \leqslant 0$ in the negative (upper) semiplane, $0 \leqslant \alpha \leqslant \pi$ in the positive (lower) semiplane
	\item \code{yaw}: insists on the \code{x}-\code{z} plane; unwraps from the positive \code{x} semi-axis; $-\pi \leqslant \alpha \leqslant 0$ in the negative (right) semiplane, $0 \leqslant \alpha \leqslant \pi$ in the positive (left) semiplane
	\item \code{roll}: insists on the \code{y}-\code{z} plane; unwraps from the positive \code{z} semi-axis; $-\pi \leqslant \alpha \leqslant 0$ in the negative (upper) semiplane, $0 \leqslant \alpha \leqslant \pi$ in the positive (lower) semiplane
\end{itemize}

\section{Virtual Test Drive}\label{sc:software:vtd}

Virtual Test Drive is a \enquote{complete tool-chain for driving simulation applications \FONTnormal{[that]} provides tools for road generation, scenario generation, traffic simulation, sound simulation, simulation control and image generation}{\cite{software:vtd}}. This project is interested in the traffic simulation part only, specifically the \software{v-traffic} module (with visual support from \software{v-scenario}). The entire software is closed source, although a number of customisation options are available.

\gls{vtd} supports two-way communication with external software using the \gls{rdb} proprietary format via either the network, or in-memory. This allows a \nth{3}-party software to interject in nearly every layer of \gls{vtd}'s simulation stack: the sales pitch accurately states that \enquote{an interactive simulation with multiple external data sources (e.g.\ simulators) is feasible and the user may influence the behavior of all entities substantially}{\cite{software:vtraffic}}.

The \software{v-traffic} module specifically provides \enquote{Vehicles \FONTnormal{[that]} may navigate autonomously in the \CHARomissis\ network}{\cite{software:vtraffic}}, among pedestrians, signalling, traffic-lights, and more. Normally, the \code{ego} vehicle (the non \gls{ai}-controlled player) is moved through acceleration, brake, and steering inputs fed to \gls{vtd} (either from internal or outside sources). In this project, the \code{ego} car will instead be moved by directly supplying its spatial coordinates in the scene.

\software{v-scenario} provides a simple top-view rendering system, that displays the scenario and the entities \software{v-traffic} is handling. The scenario within which the entities move is a road network defined in the \software{OpenDRIVE} format~\cite{software:opendrive}: for the purpose of this project, a simple racetrack with a 4-way intersection was provided; this racetrack was recreated in \gls{me} by the art team, to closely resemble the original.

\subsection{Coordinate System} % FIXME check correctness

\begin{image}
	{software/vtdcoords}{1.0}
	{\gls{vtd} coordinate system}
	{im:software:vtdcoords}
	{}
\end{image}

\subsubsection{Absolute}

The absolute coordinate system is an Euclidean space on three axes, with the $(0,0,0)$ origin being the center point of the scenario. Measures are in meters (\si{\meter}).

\begin{itemize}
	\item \code{x}: West-East axis; positive East
	\item \code{y}: North-South axis; positive North
	\item \code{z}: up-down axis; positive up
\end{itemize}

\subsubsection{Relative}

The reference point and $(0,0,0)$ origin for the geometry of each vehicle is the mid point of the rear wheels axle. Measures are also in meters (\si{\meter}).

\begin{itemize}
	\item \code{x}: vehicle length; positive forward
	\item \code{y}: vehicle width; positive right
	\item \code{z}: vehicle height; positive up
\end{itemize}

Rotations are exposed as Euclidean angles. Measures are in degrees \si{\degree}.\footnote{The roll angle visualization is left to the reader.}

\begin{itemize}
	\item \code{pitch}: insists on the \code{x}-\code{z} plane; unwraps from the positive \code{x} semi-axis; $\ang{-180} \leqslant \alpha \leqslant \ang{0}$ in the negative (lower) semiplane, $\ang{0} \leqslant \alpha \leqslant \ang{180}$ in the positive (upper) semiplane
	\item \code{yaw}: insists on the \code{x}-\code{y} plane; unwraps clockwise from the positive \code{x} semi-axis; $\ang{0} \leqslant \alpha \leqslant \ang{360}$
	\item \code{roll}: insists on the \code{y}-\code{z} plane; unwraps from the positive \code{y} semi-axis; $\ang{-180} \leqslant \alpha \leqslant \ang{0}$ in the negative (lower) semiplane, $\ang{0} \leqslant \alpha \leqslant \ang{180}$ in the positive (upper) semiplane
\end{itemize}

\subsection{Runtime Data Bus}

\gls{rdb} is the proprietary data format that \gls{vtd} provides and accepts to/from any \nth{3}-party software connected to its stack. It is a plain-text \enquote{vector of lists which contain each an array of entries of identical type}{\cite{software:rdbfaqs}}: the format specifies a large number of extensible data types, ranging from entitles meta-data, to their physical quantities (e.g.\ size, position, orientation), road details, sensor data, scenario state, and more.

Details on how this data is formatted are of limited importance. \gls{vtd} does provide an extensive \planguage{c}/\planguage{c++} \glspl{api} to parse, read, and generate \gls{rdb} \glspl{packet}; this greatly eases the procedure of composing and understanding \gls{rdb} messages. The takeaway is that, given any set of raw measures, an \gls{rdb} \gls{packet} can be efficiently built with the certainty that it adheres to the standard and is accepted by \gls{vtd}.

Based on the configuration parameters, \gls{rdb} \glspl{packet} containing specific data may be sent from \gls{vtd} to an arbitrary software residing on an \code{ip:port} over the network (data is sent to port \num{28190}). Likewise data may be sent to \gls{vtd} from an arbitrary software by connecting to \gls{vtd} on \code{ip:28191}.\footnote{Note that the port numbers presented here are not the real ones.} The frequency of the sent data can be freely varied (with a soft limit of \SI{1000}{\hertz}); \gls{vtd} on the other hand can gracefully handle any receiving rate when the synchronization is set to \code{real-time}, allowing a variable \nth{3}-party sendrate. % FIXME explain ports better

\input{mainmatter/tables/software/rdb}

In the case of this project, the following data is sent from \gls{vtd}'s \software{v-traffic} module, with a rate varying between \SI{60}{\hertz} and \SI{240}{\hertz}:

\begin{itemize}
	\item (each) entity position
	\item (each) entity orientation
	\item (each) entity velocity vector
	\item (each) entity acceleration vector
	\item (each) entity wheels angle
	\item (each) entity lights state
\end{itemize}

Similar data is sent back to \gls{vtd}'s \software{v-traffic} module:

\begin{itemize}
	\item player entity position
	\item player entity orientation
	\item player entity velocity vector
	\item player entity acceleration vector
\end{itemize}

\section{Middleware}\label{sc:software:middleware}

The middleware is an home-grown intermediary library, written in \planguage{c++},  added at compile time to \gls{me}. Its purpose is to bridge the game engine with any arbitrary traffic software, provided the latter adheres to some basic constraints:

\begin{itemize}
	\item It can communicate over the network, using the \gls{udp} protocol.
	\item It sends real-time data about the traffic entities.
	\item It is capable of accepting real-time data about the player entity.
\end{itemize}

A set of \glspl{api} is exposed, such that any \nth{3}-party may independently integrate the traffic software of their choice, without needing direct access to \gls{me}. Details on how this is achieved are in \fref{ch:middleware}, but the general idea is that the \nth{3}-party only needs to convert the data from the traffic system's format to the \gls{middleware}'s, and the other way round, without needing to handle the connection or work with \gls{me}'s coordinate system.

\begin{image}
	{software/middleware}{1.0}
	{\gls{middleware} role}
	{im:software:middleware}
	{}
\end{image}

Two similar types of network sockets were implemented, leveraging different libraries: raw \gls{os} (\gls{udp}) sockets, and \software{0mq} sockets~\cite{software:zmq}.

\subsubsection{\textsc{os} Sockets}

\gls{os} sockets use the built-in Windows \file{<Ws2tcpip>} libraries. These libraries provide low-level functions to open and close network sockets, compose, parse, send, and receive messages, and any helper functions required.

\subsubsection{0mq Sockets}

\software{0mq} sockets use the libraries provided by the \software{0mq} framework. This framework abstracts the socket creation and handling, providing high-level functions. A number of different connection paradigms are available, all high-level and easily interchangeable.

The main limitations are the lack of support for the \gls{udp} protocol, and more importantly the need to have both the sending and receiving source using \software{0mq} sockets: hybrid systems (with raw sockets on one side and \software{0mq} on the other) are not supported.

\subsection{Coordinate System}

\begin{image}
	{software/midcoords}{1.0}
	{\gls{middleware} coordinate system}
	{im:software:midcoords}
	{}
\end{image}

\subsubsection{Absolute}

The absolute coordinate system is an Euclidean space on three axes, with the $(0,0,0)$ origin being the center point of the scenario. Measures are in meters (\si{\meter}).

\begin{itemize}
	\item \code{x}: North-South axis; positive North
	\item \code{y}: West-East axis; positive West
	\item \code{z}: up-down axis; positive up
\end{itemize}

\subsubsection{Relative}

The reference point and $(0,0,0)$ origin for the geometry of each vehicle is the mid point of the front wheels axle. Measures are also in meters (\si{\meter}).

\begin{itemize}
	\item \code{x}: vehicle length; positive forward
	\item \code{y}: vehicle width; positive left
	\item \code{z}: vehicle height; positive up
\end{itemize}

Rotations are exposed as Euclidean angles. Measures are in degrees \si{\degree}.\footnote{The roll angle visualization is left to the reader.}

\begin{itemize}
	\item \code{pitch}: insists on the \code{x}-\code{z} plane; unwraps from the positive \code{x} semi-axis; $0 \leqslant \alpha \leqslant 2\pi$
	\item \code{yaw}: insists on the \code{x}-\code{y} plane; unwraps counter-clockwise from the positive \code{x} semi-axis; $0 \leqslant \alpha \leqslant 2\pi$
	\item \code{roll}: insists on the \code{y}-\code{z} plane; unwraps counter-clockwise from the positive \code{y} semi-axis; $0 \leqslant \alpha \leqslant 2\pi$
\end{itemize}

\section{Recap}\label{sc:software:recap}

In \fref{sc:software:overall} an overall view of the project was given, with broad details on the roles of each software and the interconnections between them. In \fref{sc:software:madnessengine} and \fref{sc:software:vtd} the two main software entities were presented, in enough detail to understand the development process described in the following chapters. \fref{sc:software:middleware} introduces the \gls{middleware} and its purpose, showing how it bridges \gls{me} and \gls{vtd} on the network.
