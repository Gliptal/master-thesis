\chapter{Code Analysis}\label{ch:code}

The code itself is an index of the differences between the \gls{os} and \software{\FONTsmallcaps{0mq}} implementations. The latter provides more abstract \glspl{api}, more consistent and organic functionality, an easily expandable core, and built-in scalability; the former is compatible with common non-\software{\FONTsmallcaps{0mq}} sockets, and has some minor advantages in low level socket options.

Due to the broad and subjective nature of some of these differences, the following analysis is mostly qualitative.

\section{Abstraction}\label{sc:code:abstraction}

\software{\FONTsmallcaps{0mq}}'s more abstract \glspl{api} allow for shorter, more concise, and overall clearer code. The total amount of lines dedicated to the \gls{netcode} go from \num{253} with \gls{os} sockets, to \num{151} with \software{\FONTsmallcaps{0mq}} sockets: a \SI{40,64}{\percent} decrease. Specifically, the larger decreases are in the methods that open the connections: \code{open_RX_connection()} has \SI{80,88}{\percent} less lines; \code{open_TX_connection()} has \SI{82,86}{\percent} less lines. Other than the obvious advantages in readability, less code lines result in less maintenance, less side effects when altering the code, and less failure points.

\input{mainmatter/tables/code/lines}

As an example, the two following snippets both set up a socket before a \code{bind()}:

\begin{codelist}{UDPConnector.cpp --- open\_TX\_connection() --- \FONTsmallcaps{os} sockets}{144}
    if (m_socketTXfd > -1)
        return false;

    struct sockaddr_in sock;
    uint32_t address;

    int opt;
    int result;

    InetPton(AF_INET, ip, &address);

    m_socketTXfd = socket(AF_INET, SOCK_DGRAM, 0);

    if (m_socketTXfd == -1) {
        return false;
    }

    opt = 1;
#ifdef _WIN32
    result = setsockopt(m_socketTXfd, SOL_SOCKET, SO_REUSEADDR, (char*) &opt, sizeof(opt));
#else
    int result = setsockopt(m_socketTXfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
#endif  // _WIN32

    if (result == -1) {
        return false;
    }

    opt = 1;
#ifdef _WIN32
    result = setsockopt(m_socketTXfd, SOL_SOCKET, SO_BROADCAST, (char*) &opt, sizeof(opt));
#else
    result = setsockopt(m_socketTXfd, SOL_SOCKET, SO_BROADCAST, &opt, sizeof(opt));
#endif  // _WIN32

    if (result == -1) {
        return false;
    }

    memset(&sock, 0, sizeof(sock));
    sock.sin_family      = AF_INET;
    sock.sin_addr.s_addr = address;
    sock.sin_port        = htons(port);
\end{codelist}

\begin{codelist}{UDPConnector.cpp --- open\_TX\_connection() --- \software{\FONTsmallcaps{0mq}} sockets}{100}
	std::string addr = std::string(ZMQBRIDGE_REMOTE_PROTOCOL) + "://" + std::string(ip) + ":" + std::to_string(port);
\end{codelist}

\FLOATnoindent \gls{os} sockets require defining a \code{struct sockaddr_in}, to enclose some basic protocol options (\code{SOCK_DGRAM}, \code{SO_REUSEADDR}), the socket's \gls{ip} address and port, and additional meta settings; \software{\FONTsmallcaps{0mq}} sockets achieve the same result through a single string, with meta settings internally set by \software{\FONTsmallcaps{0mq}} itself: e.g.\ \code{"tcp://192.168.1.100:5555"} is formed by:

\begin{itemize}
	\item \FONTbold{\code{"tcp"}} --- the protocol (line \num{155} in the \gls{os} sockets implementation);
	\item \FONTbold{\code{"192.168.1.1"}} --- the \gls{ip} (lines \num{153} and \num{185} in the \gls{os} sockets implementation);
	\item \FONTbold{\code{"5555"}} --- the port (line \num{186} in the \gls{os} sockets implementation).
\end{itemize}

\FLOATnoindent Also of note is memory handling, necessary for the  \code{struct sockaddr_in} (a \code{memset()} call), and entirely missing in the \software{\FONTsmallcaps{0mq}} solution.

Since \software{\FONTsmallcaps{0mq}} sockets are proper objects (of type \code{void*}) and not simple \code{int}(s) representing file descriptors, the constructor's code is instead marginally more involved:

\begin{codelist}{UDPConnector.cpp --- UDPConnector() --- \FONTsmallcaps{os} sockets}{60}
UDPConnector::UDPConnector() {
	m_context  = zmq_ctx_new();
	m_socketRX = zmq_socket(m_context, ZMQ_SUB);
	m_socketTX = zmq_socket(m_context, ZMQ_PUB);

	m_payloadRX = (char*) malloc(UDPCONNECTOR_ME_PAYLOAD_BUFFER);
	m_payloadTX = (char*) malloc(UDPCONNECTOR_ME_PAYLOAD_BUFFER);
}
\end{codelist}

\begin{codelist}{UDPConnector.cpp --- UDPConnector() --- \software{\FONTsmallcaps{0mq}} sockets}{63}
UDPConnector::UDPConnector() {
	m_payloadRX = (char*) malloc(UDPCONNECTOR_ME_PAYLOAD_BUFFER);
	m_payloadTX = (char*) malloc(UDPCONNECTOR_ME_PAYLOAD_BUFFER);
}
\end{codelist} % FORMATTING fit this in the page

\FLOATnoindent \code{m_context} is required by \software{\FONTsmallcaps{0mq}} sockets, since it encapsulates state information and some general settings (here left to their defaults): at creation, sockets are assigned to a specific context.

\section{Ease}\label{sc:code:ease}

Coding with \software{\FONTsmallcaps{0mq}} proved to be a much simpler and faster process than using \gls{os} headers. \fref{sc:code:abstraction} already presented an example: generating and setting up a socket is a lot less involved, thanks to high-level methods and abstraction. It should also be noted that the two implementations differ in protocol, and that a proper \gls{tcp} implementation with \gls{os} sockets would require non-trivially more complicated memory management when sending and receiving, something that \software{\FONTsmallcaps{0mq}} entirely hides behind the \code{zmq_send()} and \code{zmq_recv()} functions.

\section{Expandability}\label{sc:code:expandability}

\software{\FONTsmallcaps{0mq}} provides bindings that allow major \gls{netcode} variations with minimal code changes. e.g.\ the protocol can be easily switched by prepending a different string to the \code{addr} variable (set in the \code{ZMQBRIDGE_REMOTE_PROTOCOL} define); the sockets paradigm (\FONTsmallcaps{pub}/\FONTsmallcaps{sub} in this project) can similarly be changed by altering the constructor. In both cases the rest of the code remains unchanged and keeps its functionality, since the actual implementation of the protocol and sockets is hidden by the high-level object methods.

For example, switching from a \gls{tcp} \FONTsmallcaps{pub}/\FONTsmallcaps{sub} paradigm to an \code{inproc} (in-memory) \FONTsmallcaps{pair} paradigm only requires changing three lines of code:

\begin{codelist}{\gls{tcp}}{1}
#define ZMQBRIDGE_REMOTE_PROTOCOL "tcp"
m_socketRX = zmq_socket(m_context, ZMQ_SUB);
m_socketTX = zmq_socket(m_context, ZMQ_PUB);
\end{codelist}

\begin{codelist}{inproc}{1}
#define ZMQBRIDGE_REMOTE_PROTOCOL "inproc"
m_socketRX = zmq_socket(m_context, ZMQ_PAIR);
m_socketTX = zmq_socket(m_context, ZMQ_PAIR);
\end{codelist}

\FLOATnoindent Achieving a similar results with an \gls{os}-based implementation would require an extensive rewrite of the lower level code, to cater for the different protocol and properly pair the sockets with each other.

Additionally, \software{\FONTsmallcaps{0mq}} is by construction fully scalable. Additional software may be freely added to the system, with no changes required to the underlying \gls{netcode} layer: different \glspl{ts} could be used simultaneously by adding additional sockets (\code{zmq_socket()} constructor call). The  \FONTsmallcaps{pub}/\FONTsmallcaps{sub} paradigm also natively supports subscription lists, where subbed sockets only receive specifically marked packets, ignoring the others: a \gls{ts} could mark specific data, for example differentiating a vehicle's state vectors and data on the scenario's state, to reduce the workload on the game engine.

\section{Recap}\label{sc:code:recap}

This chapter broadly described the code style and functional differences between \software{\FONTsmallcaps{0mq}} and \gls{os} sockets. \software{\FONTsmallcaps{0mq}} sockets have a large advantage thanks to higher abstraction (\fref{sc:code:abstraction}), coding ease (\fref{sc:code:ease}), and easier expandability (\fref{sc:code:expandability}).
